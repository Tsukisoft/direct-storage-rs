// Bindings generated by `windows-bindgen` 0.52.0

#![allow(
    non_snake_case,
    non_upper_case_globals,
    non_camel_case_types,
    dead_code,
    clippy::all
)]
pub mod Direct3D {
    pub mod DirectStorage {
        #[inline]
        pub unsafe fn DStorageCreateCompressionCodec<T>(
            format: DSTORAGE_COMPRESSION_FORMAT,
            numthreads: u32,
        ) -> ::windows_core::Result<T>
        where
            T: ::windows_core::ComInterface,
        {
            #[link(name = "dstorage")]
            extern "system" {
                pub fn DStorageCreateCompressionCodec(
                    format: DSTORAGE_COMPRESSION_FORMAT,
                    numthreads: u32,
                    riid: *const ::windows_core::GUID,
                    ppv: *mut *mut ::core::ffi::c_void,
                ) -> ::windows_core::HRESULT;
            }
            let mut result__ = ::std::ptr::null_mut();
            DStorageCreateCompressionCodec(
                format,
                numthreads,
                &<T as ::windows_core::ComInterface>::IID,
                &mut result__,
            )
            .from_abi(result__)
        }
        #[inline]
        pub unsafe fn DStorageGetFactory<T>() -> ::windows_core::Result<T>
        where
            T: ::windows_core::ComInterface,
        {
            #[link(name = "dstorage")]
            extern "system" {
                pub fn DStorageGetFactory(
                    riid: *const ::windows_core::GUID,
                    ppv: *mut *mut ::core::ffi::c_void,
                ) -> ::windows_core::HRESULT;
            }
            let mut result__ = ::std::ptr::null_mut();
            DStorageGetFactory(&<T as ::windows_core::ComInterface>::IID, &mut result__)
                .from_abi(result__)
        }
        #[inline]
        pub unsafe fn DStorageSetConfiguration(
            configuration: *const DSTORAGE_CONFIGURATION,
        ) -> ::windows_core::Result<()> {
            #[link(name = "dstorage")]
            extern "system" {
                pub fn DStorageSetConfiguration(
                    configuration: *const DSTORAGE_CONFIGURATION,
                ) -> ::windows_core::HRESULT;
            }
            DStorageSetConfiguration(configuration).ok()
        }
        #[repr(transparent)]
        #[derive(
            ::core::cmp::PartialEq, ::core::cmp::Eq, ::core::fmt::Debug, ::core::clone::Clone,
        )]
        pub struct IDStorageCompressionCodec(::windows_core::IUnknown);
        impl IDStorageCompressionCodec {
            pub unsafe fn CompressBuffer(
                &self,
                uncompresseddata: *const ::core::ffi::c_void,
                uncompresseddatasize: usize,
                compressionsetting: DSTORAGE_COMPRESSION,
                compressedbuffer: *mut ::core::ffi::c_void,
                compressedbuffersize: usize,
                compresseddatasize: *mut usize,
            ) -> ::windows_core::Result<()> {
                (::windows_core::Interface::vtable(self).CompressBuffer)(
                    ::windows_core::Interface::as_raw(self),
                    uncompresseddata,
                    uncompresseddatasize,
                    compressionsetting,
                    compressedbuffer,
                    compressedbuffersize,
                    compresseddatasize,
                )
                .ok()
            }
            pub unsafe fn DecompressBuffer(
                &self,
                compresseddata: *const ::core::ffi::c_void,
                compresseddatasize: usize,
                uncompressedbuffer: *mut ::core::ffi::c_void,
                uncompressedbuffersize: usize,
                uncompresseddatasize: *mut usize,
            ) -> ::windows_core::Result<()> {
                (::windows_core::Interface::vtable(self).DecompressBuffer)(
                    ::windows_core::Interface::as_raw(self),
                    compresseddata,
                    compresseddatasize,
                    uncompressedbuffer,
                    uncompressedbuffersize,
                    uncompresseddatasize,
                )
                .ok()
            }
            pub unsafe fn CompressBufferBound(&self, uncompresseddatasize: usize) -> usize {
                (::windows_core::Interface::vtable(self).CompressBufferBound)(
                    ::windows_core::Interface::as_raw(self),
                    uncompresseddatasize,
                )
            }
        }
        ::windows_core::imp::interface_hierarchy!(
            IDStorageCompressionCodec,
            ::windows_core::IUnknown
        );
        unsafe impl ::windows_core::Interface for IDStorageCompressionCodec {
            type Vtable = IDStorageCompressionCodec_Vtbl;
        }
        unsafe impl ::windows_core::ComInterface for IDStorageCompressionCodec {
            const IID: ::windows_core::GUID =
                ::windows_core::GUID::from_u128(0x84ef5121_9b43_4d03_b5c1_cc34606b262d);
        }
        #[repr(C)]
        #[doc(hidden)]
        pub struct IDStorageCompressionCodec_Vtbl {
            pub base__: ::windows_core::IUnknown_Vtbl,
            pub CompressBuffer: unsafe extern "system" fn(
                this: *mut ::core::ffi::c_void,
                uncompresseddata: *const ::core::ffi::c_void,
                uncompresseddatasize: usize,
                compressionsetting: DSTORAGE_COMPRESSION,
                compressedbuffer: *mut ::core::ffi::c_void,
                compressedbuffersize: usize,
                compresseddatasize: *mut usize,
            ) -> ::windows_core::HRESULT,
            pub DecompressBuffer: unsafe extern "system" fn(
                this: *mut ::core::ffi::c_void,
                compresseddata: *const ::core::ffi::c_void,
                compresseddatasize: usize,
                uncompressedbuffer: *mut ::core::ffi::c_void,
                uncompressedbuffersize: usize,
                uncompresseddatasize: *mut usize,
            ) -> ::windows_core::HRESULT,
            pub CompressBufferBound: unsafe extern "system" fn(
                this: *mut ::core::ffi::c_void,
                uncompresseddatasize: usize,
            ) -> usize,
        }
        #[repr(transparent)]
        #[derive(
            ::core::cmp::PartialEq, ::core::cmp::Eq, ::core::fmt::Debug, ::core::clone::Clone,
        )]
        pub struct IDStorageCustomDecompressionQueue(::windows_core::IUnknown);
        impl IDStorageCustomDecompressionQueue {
            pub unsafe fn GetEvent(&self) -> ::windows::Win32::Foundation::HANDLE {
                (::windows_core::Interface::vtable(self).GetEvent)(
                    ::windows_core::Interface::as_raw(self),
                )
            }
            pub unsafe fn GetRequests(
                &self,
                requests: &mut [DSTORAGE_CUSTOM_DECOMPRESSION_REQUEST],
                numrequests: *mut u32,
            ) -> ::windows_core::Result<()> {
                (::windows_core::Interface::vtable(self).GetRequests)(
                    ::windows_core::Interface::as_raw(self),
                    requests.len().try_into().unwrap(),
                    ::core::mem::transmute(requests.as_ptr()),
                    numrequests,
                )
                .ok()
            }
            pub unsafe fn SetRequestResults(
                &self,
                results: &[DSTORAGE_CUSTOM_DECOMPRESSION_RESULT],
            ) -> ::windows_core::Result<()> {
                (::windows_core::Interface::vtable(self).SetRequestResults)(
                    ::windows_core::Interface::as_raw(self),
                    results.len().try_into().unwrap(),
                    ::core::mem::transmute(results.as_ptr()),
                )
                .ok()
            }
        }
        ::windows_core::imp::interface_hierarchy!(
            IDStorageCustomDecompressionQueue,
            ::windows_core::IUnknown
        );
        unsafe impl ::windows_core::Interface for IDStorageCustomDecompressionQueue {
            type Vtable = IDStorageCustomDecompressionQueue_Vtbl;
        }
        unsafe impl ::windows_core::ComInterface for IDStorageCustomDecompressionQueue {
            const IID: ::windows_core::GUID =
                ::windows_core::GUID::from_u128(0x97179b2f_2c21_49ca_8291_4e1bf4a160df);
        }
        #[repr(C)]
        #[doc(hidden)]
        pub struct IDStorageCustomDecompressionQueue_Vtbl {
            pub base__: ::windows_core::IUnknown_Vtbl,
            pub GetEvent: unsafe extern "system" fn(
                this: *mut ::core::ffi::c_void,
            )
                -> ::windows::Win32::Foundation::HANDLE,
            pub GetRequests: unsafe extern "system" fn(
                this: *mut ::core::ffi::c_void,
                maxrequests: u32,
                requests: *mut DSTORAGE_CUSTOM_DECOMPRESSION_REQUEST,
                numrequests: *mut u32,
            ) -> ::windows_core::HRESULT,
            pub SetRequestResults: unsafe extern "system" fn(
                this: *mut ::core::ffi::c_void,
                numresults: u32,
                results: *const DSTORAGE_CUSTOM_DECOMPRESSION_RESULT,
            )
                -> ::windows_core::HRESULT,
        }
        #[repr(transparent)]
        #[derive(
            ::core::cmp::PartialEq, ::core::cmp::Eq, ::core::fmt::Debug, ::core::clone::Clone,
        )]
        pub struct IDStorageCustomDecompressionQueue1(::windows_core::IUnknown);
        impl IDStorageCustomDecompressionQueue1 {
            pub unsafe fn GetEvent(&self) -> ::windows::Win32::Foundation::HANDLE {
                (::windows_core::Interface::vtable(self).base__.GetEvent)(
                    ::windows_core::Interface::as_raw(self),
                )
            }
            pub unsafe fn GetRequests(
                &self,
                requests: &mut [DSTORAGE_CUSTOM_DECOMPRESSION_REQUEST],
                numrequests: *mut u32,
            ) -> ::windows_core::Result<()> {
                (::windows_core::Interface::vtable(self).base__.GetRequests)(
                    ::windows_core::Interface::as_raw(self),
                    requests.len().try_into().unwrap(),
                    ::core::mem::transmute(requests.as_ptr()),
                    numrequests,
                )
                .ok()
            }
            pub unsafe fn SetRequestResults(
                &self,
                results: &[DSTORAGE_CUSTOM_DECOMPRESSION_RESULT],
            ) -> ::windows_core::Result<()> {
                (::windows_core::Interface::vtable(self)
                    .base__
                    .SetRequestResults)(
                    ::windows_core::Interface::as_raw(self),
                    results.len().try_into().unwrap(),
                    ::core::mem::transmute(results.as_ptr()),
                )
                .ok()
            }
            pub unsafe fn GetRequests1(
                &self,
                flags: DSTORAGE_GET_REQUEST_FLAGS,
                requests: &mut [DSTORAGE_CUSTOM_DECOMPRESSION_REQUEST],
                numrequests: *mut u32,
            ) -> ::windows_core::Result<()> {
                (::windows_core::Interface::vtable(self).GetRequests1)(
                    ::windows_core::Interface::as_raw(self),
                    flags,
                    requests.len().try_into().unwrap(),
                    ::core::mem::transmute(requests.as_ptr()),
                    numrequests,
                )
                .ok()
            }
        }
        ::windows_core::imp::interface_hierarchy!(
            IDStorageCustomDecompressionQueue1,
            ::windows_core::IUnknown,
            IDStorageCustomDecompressionQueue
        );
        unsafe impl ::windows_core::Interface for IDStorageCustomDecompressionQueue1 {
            type Vtable = IDStorageCustomDecompressionQueue1_Vtbl;
        }
        unsafe impl ::windows_core::ComInterface for IDStorageCustomDecompressionQueue1 {
            const IID: ::windows_core::GUID =
                ::windows_core::GUID::from_u128(0x0d47c6c9_e61a_4706_93b4_68bfe3f4aa4a);
        }
        #[repr(C)]
        #[doc(hidden)]
        pub struct IDStorageCustomDecompressionQueue1_Vtbl {
            pub base__: IDStorageCustomDecompressionQueue_Vtbl,
            pub GetRequests1: unsafe extern "system" fn(
                this: *mut ::core::ffi::c_void,
                flags: DSTORAGE_GET_REQUEST_FLAGS,
                maxrequests: u32,
                requests: *mut DSTORAGE_CUSTOM_DECOMPRESSION_REQUEST,
                numrequests: *mut u32,
            ) -> ::windows_core::HRESULT,
        }
        #[repr(transparent)]
        #[derive(
            ::core::cmp::PartialEq, ::core::cmp::Eq, ::core::fmt::Debug, ::core::clone::Clone,
        )]
        pub struct IDStorageFactory(::windows_core::IUnknown);
        impl IDStorageFactory {
            pub unsafe fn CreateQueue<T>(
                &self,
                desc: *const DSTORAGE_QUEUE_DESC,
            ) -> ::windows_core::Result<T>
            where
                T: ::windows_core::ComInterface,
            {
                let mut result__ = ::std::ptr::null_mut();
                (::windows_core::Interface::vtable(self).CreateQueue)(
                    ::windows_core::Interface::as_raw(self),
                    desc,
                    &<T as ::windows_core::ComInterface>::IID,
                    &mut result__,
                )
                .from_abi(result__)
            }
            pub unsafe fn OpenFile<P0, T>(&self, path: P0) -> ::windows_core::Result<T>
            where
                P0: ::windows_core::IntoParam<::windows_core::PCWSTR>,
                T: ::windows_core::ComInterface,
            {
                let mut result__ = ::std::ptr::null_mut();
                (::windows_core::Interface::vtable(self).OpenFile)(
                    ::windows_core::Interface::as_raw(self),
                    path.into_param().abi(),
                    &<T as ::windows_core::ComInterface>::IID,
                    &mut result__,
                )
                .from_abi(result__)
            }
            pub unsafe fn CreateStatusArray<P0, T>(
                &self,
                capacity: u32,
                name: P0,
            ) -> ::windows_core::Result<T>
            where
                P0: ::windows_core::IntoParam<::windows_core::PCSTR>,
                T: ::windows_core::ComInterface,
            {
                let mut result__ = ::std::ptr::null_mut();
                (::windows_core::Interface::vtable(self).CreateStatusArray)(
                    ::windows_core::Interface::as_raw(self),
                    capacity,
                    name.into_param().abi(),
                    &<T as ::windows_core::ComInterface>::IID,
                    &mut result__,
                )
                .from_abi(result__)
            }
            pub unsafe fn SetDebugFlags(&self, flags: u32) {
                (::windows_core::Interface::vtable(self).SetDebugFlags)(
                    ::windows_core::Interface::as_raw(self),
                    flags,
                )
            }
            pub unsafe fn SetStagingBufferSize(&self, size: u32) -> ::windows_core::Result<()> {
                (::windows_core::Interface::vtable(self).SetStagingBufferSize)(
                    ::windows_core::Interface::as_raw(self),
                    size,
                )
                .ok()
            }
        }
        ::windows_core::imp::interface_hierarchy!(IDStorageFactory, ::windows_core::IUnknown);
        unsafe impl ::windows_core::Interface for IDStorageFactory {
            type Vtable = IDStorageFactory_Vtbl;
        }
        unsafe impl ::windows_core::ComInterface for IDStorageFactory {
            const IID: ::windows_core::GUID =
                ::windows_core::GUID::from_u128(0x6924ea0c_c3cd_4826_b10a_f64f4ed927c1);
        }
        #[repr(C)]
        #[doc(hidden)]
        pub struct IDStorageFactory_Vtbl {
            pub base__: ::windows_core::IUnknown_Vtbl,
            pub CreateQueue: unsafe extern "system" fn(
                this: *mut ::core::ffi::c_void,
                desc: *const DSTORAGE_QUEUE_DESC,
                riid: *const ::windows_core::GUID,
                ppv: *mut *mut ::core::ffi::c_void,
            ) -> ::windows_core::HRESULT,
            pub OpenFile: unsafe extern "system" fn(
                this: *mut ::core::ffi::c_void,
                path: ::windows_core::PCWSTR,
                riid: *const ::windows_core::GUID,
                ppv: *mut *mut ::core::ffi::c_void,
            ) -> ::windows_core::HRESULT,
            pub CreateStatusArray: unsafe extern "system" fn(
                this: *mut ::core::ffi::c_void,
                capacity: u32,
                name: ::windows_core::PCSTR,
                riid: *const ::windows_core::GUID,
                ppv: *mut *mut ::core::ffi::c_void,
            )
                -> ::windows_core::HRESULT,
            pub SetDebugFlags:
                unsafe extern "system" fn(this: *mut ::core::ffi::c_void, flags: u32),
            pub SetStagingBufferSize: unsafe extern "system" fn(
                this: *mut ::core::ffi::c_void,
                size: u32,
            )
                -> ::windows_core::HRESULT,
        }
        #[repr(transparent)]
        #[derive(
            ::core::cmp::PartialEq, ::core::cmp::Eq, ::core::fmt::Debug, ::core::clone::Clone,
        )]
        pub struct IDStorageFile(::windows_core::IUnknown);
        impl IDStorageFile {
            pub unsafe fn Close(&self) {
                (::windows_core::Interface::vtable(self).Close)(::windows_core::Interface::as_raw(
                    self,
                ))
            }
            pub unsafe fn GetFileInformation(
                &self,
                info: *mut ::windows::Win32::Storage::FileSystem::BY_HANDLE_FILE_INFORMATION,
            ) -> ::windows_core::Result<()> {
                (::windows_core::Interface::vtable(self).GetFileInformation)(
                    ::windows_core::Interface::as_raw(self),
                    info,
                )
                .ok()
            }
        }
        ::windows_core::imp::interface_hierarchy!(IDStorageFile, ::windows_core::IUnknown);
        unsafe impl ::windows_core::Interface for IDStorageFile {
            type Vtable = IDStorageFile_Vtbl;
        }
        unsafe impl ::windows_core::ComInterface for IDStorageFile {
            const IID: ::windows_core::GUID =
                ::windows_core::GUID::from_u128(0x5de95e7b_955a_4868_a73c_243b29f4b8da);
        }
        #[repr(C)]
        #[doc(hidden)]
        pub struct IDStorageFile_Vtbl {
            pub base__: ::windows_core::IUnknown_Vtbl,
            pub Close: unsafe extern "system" fn(this: *mut ::core::ffi::c_void),
            pub GetFileInformation: unsafe extern "system" fn(
                this: *mut ::core::ffi::c_void,
                info: *mut ::windows::Win32::Storage::FileSystem::BY_HANDLE_FILE_INFORMATION,
            )
                -> ::windows_core::HRESULT,
        }
        #[repr(transparent)]
        #[derive(
            ::core::cmp::PartialEq, ::core::cmp::Eq, ::core::fmt::Debug, ::core::clone::Clone,
        )]
        pub struct IDStorageQueue(::windows_core::IUnknown);
        impl IDStorageQueue {
            pub unsafe fn EnqueueRequest(&self, request: *const DSTORAGE_REQUEST) {
                (::windows_core::Interface::vtable(self).EnqueueRequest)(
                    ::windows_core::Interface::as_raw(self),
                    request,
                )
            }
            pub unsafe fn EnqueueStatus<P0>(&self, statusarray: P0, index: u32)
            where
                P0: ::windows_core::IntoParam<IDStorageStatusArray>,
            {
                (::windows_core::Interface::vtable(self).EnqueueStatus)(
                    ::windows_core::Interface::as_raw(self),
                    statusarray.into_param().abi(),
                    index,
                )
            }
            pub unsafe fn EnqueueSignal<P0>(&self, fence: P0, value: u64)
            where
                P0: ::windows_core::IntoParam<::windows::Win32::Graphics::Direct3D12::ID3D12Fence>,
            {
                (::windows_core::Interface::vtable(self).EnqueueSignal)(
                    ::windows_core::Interface::as_raw(self),
                    fence.into_param().abi(),
                    value,
                )
            }
            pub unsafe fn Submit(&self) {
                (::windows_core::Interface::vtable(self).Submit)(::windows_core::Interface::as_raw(
                    self,
                ))
            }
            pub unsafe fn CancelRequestsWithTag(&self, mask: u64, value: u64) {
                (::windows_core::Interface::vtable(self).CancelRequestsWithTag)(
                    ::windows_core::Interface::as_raw(self),
                    mask,
                    value,
                )
            }
            pub unsafe fn Close(&self) {
                (::windows_core::Interface::vtable(self).Close)(::windows_core::Interface::as_raw(
                    self,
                ))
            }
            pub unsafe fn GetErrorEvent(&self) -> ::windows::Win32::Foundation::HANDLE {
                (::windows_core::Interface::vtable(self).GetErrorEvent)(
                    ::windows_core::Interface::as_raw(self),
                )
            }
            pub unsafe fn RetrieveErrorRecord(&self, record: *mut DSTORAGE_ERROR_RECORD) {
                (::windows_core::Interface::vtable(self).RetrieveErrorRecord)(
                    ::windows_core::Interface::as_raw(self),
                    record,
                )
            }
            pub unsafe fn Query(&self, info: *mut DSTORAGE_QUEUE_INFO) {
                (::windows_core::Interface::vtable(self).Query)(
                    ::windows_core::Interface::as_raw(self),
                    info,
                )
            }
        }
        ::windows_core::imp::interface_hierarchy!(IDStorageQueue, ::windows_core::IUnknown);
        unsafe impl ::windows_core::Interface for IDStorageQueue {
            type Vtable = IDStorageQueue_Vtbl;
        }
        unsafe impl ::windows_core::ComInterface for IDStorageQueue {
            const IID: ::windows_core::GUID =
                ::windows_core::GUID::from_u128(0xcfdbd83f_9e06_4fda_8ea5_69042137f49b);
        }
        #[repr(C)]
        #[doc(hidden)]
        pub struct IDStorageQueue_Vtbl {
            pub base__: ::windows_core::IUnknown_Vtbl,
            pub EnqueueRequest: unsafe extern "system" fn(
                this: *mut ::core::ffi::c_void,
                request: *const DSTORAGE_REQUEST,
            ),
            pub EnqueueStatus: unsafe extern "system" fn(
                this: *mut ::core::ffi::c_void,
                statusarray: *mut ::core::ffi::c_void,
                index: u32,
            ),
            pub EnqueueSignal: unsafe extern "system" fn(
                this: *mut ::core::ffi::c_void,
                fence: *mut ::core::ffi::c_void,
                value: u64,
            ),
            pub Submit: unsafe extern "system" fn(this: *mut ::core::ffi::c_void),
            pub CancelRequestsWithTag:
                unsafe extern "system" fn(this: *mut ::core::ffi::c_void, mask: u64, value: u64),
            pub Close: unsafe extern "system" fn(this: *mut ::core::ffi::c_void),
            pub GetErrorEvent: unsafe extern "system" fn(
                this: *mut ::core::ffi::c_void,
            )
                -> ::windows::Win32::Foundation::HANDLE,
            pub RetrieveErrorRecord: unsafe extern "system" fn(
                this: *mut ::core::ffi::c_void,
                record: *mut DSTORAGE_ERROR_RECORD,
            ),
            pub Query: unsafe extern "system" fn(
                this: *mut ::core::ffi::c_void,
                info: *mut DSTORAGE_QUEUE_INFO,
            ),
        }
        #[repr(transparent)]
        #[derive(
            ::core::cmp::PartialEq, ::core::cmp::Eq, ::core::fmt::Debug, ::core::clone::Clone,
        )]
        pub struct IDStorageQueue1(::windows_core::IUnknown);
        impl IDStorageQueue1 {
            pub unsafe fn EnqueueRequest(&self, request: *const DSTORAGE_REQUEST) {
                (::windows_core::Interface::vtable(self)
                    .base__
                    .EnqueueRequest)(
                    ::windows_core::Interface::as_raw(self), request
                )
            }
            pub unsafe fn EnqueueStatus<P0>(&self, statusarray: P0, index: u32)
            where
                P0: ::windows_core::IntoParam<IDStorageStatusArray>,
            {
                (::windows_core::Interface::vtable(self).base__.EnqueueStatus)(
                    ::windows_core::Interface::as_raw(self),
                    statusarray.into_param().abi(),
                    index,
                )
            }
            pub unsafe fn EnqueueSignal<P0>(&self, fence: P0, value: u64)
            where
                P0: ::windows_core::IntoParam<::windows::Win32::Graphics::Direct3D12::ID3D12Fence>,
            {
                (::windows_core::Interface::vtable(self).base__.EnqueueSignal)(
                    ::windows_core::Interface::as_raw(self),
                    fence.into_param().abi(),
                    value,
                )
            }
            pub unsafe fn Submit(&self) {
                (::windows_core::Interface::vtable(self).base__.Submit)(
                    ::windows_core::Interface::as_raw(self),
                )
            }
            pub unsafe fn CancelRequestsWithTag(&self, mask: u64, value: u64) {
                (::windows_core::Interface::vtable(self)
                    .base__
                    .CancelRequestsWithTag)(
                    ::windows_core::Interface::as_raw(self), mask, value
                )
            }
            pub unsafe fn Close(&self) {
                (::windows_core::Interface::vtable(self).base__.Close)(
                    ::windows_core::Interface::as_raw(self),
                )
            }
            pub unsafe fn GetErrorEvent(&self) -> ::windows::Win32::Foundation::HANDLE {
                (::windows_core::Interface::vtable(self).base__.GetErrorEvent)(
                    ::windows_core::Interface::as_raw(self),
                )
            }
            pub unsafe fn RetrieveErrorRecord(&self, record: *mut DSTORAGE_ERROR_RECORD) {
                (::windows_core::Interface::vtable(self)
                    .base__
                    .RetrieveErrorRecord)(
                    ::windows_core::Interface::as_raw(self), record
                )
            }
            pub unsafe fn Query(&self, info: *mut DSTORAGE_QUEUE_INFO) {
                (::windows_core::Interface::vtable(self).base__.Query)(
                    ::windows_core::Interface::as_raw(self),
                    info,
                )
            }
            pub unsafe fn EnqueueSetEvent<P0>(&self, handle: P0)
            where
                P0: ::windows_core::IntoParam<::windows::Win32::Foundation::HANDLE>,
            {
                (::windows_core::Interface::vtable(self).EnqueueSetEvent)(
                    ::windows_core::Interface::as_raw(self),
                    handle.into_param().abi(),
                )
            }
        }
        ::windows_core::imp::interface_hierarchy!(
            IDStorageQueue1,
            ::windows_core::IUnknown,
            IDStorageQueue
        );
        unsafe impl ::windows_core::Interface for IDStorageQueue1 {
            type Vtable = IDStorageQueue1_Vtbl;
        }
        unsafe impl ::windows_core::ComInterface for IDStorageQueue1 {
            const IID: ::windows_core::GUID =
                ::windows_core::GUID::from_u128(0xdd2f482c_5eff_41e8_9c9e_d2374b278128);
        }
        #[repr(C)]
        #[doc(hidden)]
        pub struct IDStorageQueue1_Vtbl {
            pub base__: IDStorageQueue_Vtbl,
            pub EnqueueSetEvent: unsafe extern "system" fn(
                this: *mut ::core::ffi::c_void,
                handle: ::windows::Win32::Foundation::HANDLE,
            ),
        }
        #[repr(transparent)]
        #[derive(
            ::core::cmp::PartialEq, ::core::cmp::Eq, ::core::fmt::Debug, ::core::clone::Clone,
        )]
        pub struct IDStorageQueue2(::windows_core::IUnknown);
        impl IDStorageQueue2 {
            pub unsafe fn EnqueueRequest(&self, request: *const DSTORAGE_REQUEST) {
                (::windows_core::Interface::vtable(self)
                    .base__
                    .base__
                    .EnqueueRequest)(
                    ::windows_core::Interface::as_raw(self), request
                )
            }
            pub unsafe fn EnqueueStatus<P0>(&self, statusarray: P0, index: u32)
            where
                P0: ::windows_core::IntoParam<IDStorageStatusArray>,
            {
                (::windows_core::Interface::vtable(self)
                    .base__
                    .base__
                    .EnqueueStatus)(
                    ::windows_core::Interface::as_raw(self),
                    statusarray.into_param().abi(),
                    index,
                )
            }
            pub unsafe fn EnqueueSignal<P0>(&self, fence: P0, value: u64)
            where
                P0: ::windows_core::IntoParam<::windows::Win32::Graphics::Direct3D12::ID3D12Fence>,
            {
                (::windows_core::Interface::vtable(self)
                    .base__
                    .base__
                    .EnqueueSignal)(
                    ::windows_core::Interface::as_raw(self),
                    fence.into_param().abi(),
                    value,
                )
            }
            pub unsafe fn Submit(&self) {
                (::windows_core::Interface::vtable(self).base__.base__.Submit)(
                    ::windows_core::Interface::as_raw(self),
                )
            }
            pub unsafe fn CancelRequestsWithTag(&self, mask: u64, value: u64) {
                (::windows_core::Interface::vtable(self)
                    .base__
                    .base__
                    .CancelRequestsWithTag)(
                    ::windows_core::Interface::as_raw(self), mask, value
                )
            }
            pub unsafe fn Close(&self) {
                (::windows_core::Interface::vtable(self).base__.base__.Close)(
                    ::windows_core::Interface::as_raw(self),
                )
            }
            pub unsafe fn GetErrorEvent(&self) -> ::windows::Win32::Foundation::HANDLE {
                (::windows_core::Interface::vtable(self)
                    .base__
                    .base__
                    .GetErrorEvent)(::windows_core::Interface::as_raw(self))
            }
            pub unsafe fn RetrieveErrorRecord(&self, record: *mut DSTORAGE_ERROR_RECORD) {
                (::windows_core::Interface::vtable(self)
                    .base__
                    .base__
                    .RetrieveErrorRecord)(
                    ::windows_core::Interface::as_raw(self), record
                )
            }
            pub unsafe fn Query(&self, info: *mut DSTORAGE_QUEUE_INFO) {
                (::windows_core::Interface::vtable(self).base__.base__.Query)(
                    ::windows_core::Interface::as_raw(self),
                    info,
                )
            }
            pub unsafe fn EnqueueSetEvent<P0>(&self, handle: P0)
            where
                P0: ::windows_core::IntoParam<::windows::Win32::Foundation::HANDLE>,
            {
                (::windows_core::Interface::vtable(self)
                    .base__
                    .EnqueueSetEvent)(
                    ::windows_core::Interface::as_raw(self),
                    handle.into_param().abi(),
                )
            }
            pub unsafe fn GetCompressionSupport(
                &self,
                format: DSTORAGE_COMPRESSION_FORMAT,
            ) -> DSTORAGE_COMPRESSION_SUPPORT {
                (::windows_core::Interface::vtable(self).GetCompressionSupport)(
                    ::windows_core::Interface::as_raw(self),
                    format,
                )
            }
        }
        ::windows_core::imp::interface_hierarchy!(
            IDStorageQueue2,
            ::windows_core::IUnknown,
            IDStorageQueue,
            IDStorageQueue1
        );
        unsafe impl ::windows_core::Interface for IDStorageQueue2 {
            type Vtable = IDStorageQueue2_Vtbl;
        }
        unsafe impl ::windows_core::ComInterface for IDStorageQueue2 {
            const IID: ::windows_core::GUID =
                ::windows_core::GUID::from_u128(0xb1c9d643_3a49_44a2_b46f_653649470d18);
        }
        #[repr(C)]
        #[doc(hidden)]
        pub struct IDStorageQueue2_Vtbl {
            pub base__: IDStorageQueue1_Vtbl,
            pub GetCompressionSupport: unsafe extern "system" fn(
                this: *mut ::core::ffi::c_void,
                format: DSTORAGE_COMPRESSION_FORMAT,
            )
                -> DSTORAGE_COMPRESSION_SUPPORT,
        }
        #[repr(transparent)]
        #[derive(
            ::core::cmp::PartialEq, ::core::cmp::Eq, ::core::fmt::Debug, ::core::clone::Clone,
        )]
        pub struct IDStorageStatusArray(::windows_core::IUnknown);
        impl IDStorageStatusArray {
            pub unsafe fn IsComplete(&self, index: u32) -> bool {
                (::windows_core::Interface::vtable(self).IsComplete)(
                    ::windows_core::Interface::as_raw(self),
                    index,
                )
            }
            pub unsafe fn GetHResult(&self, index: u32) -> ::windows_core::Result<()> {
                (::windows_core::Interface::vtable(self).GetHResult)(
                    ::windows_core::Interface::as_raw(self),
                    index,
                )
                .ok()
            }
        }
        ::windows_core::imp::interface_hierarchy!(IDStorageStatusArray, ::windows_core::IUnknown);
        unsafe impl ::windows_core::Interface for IDStorageStatusArray {
            type Vtable = IDStorageStatusArray_Vtbl;
        }
        unsafe impl ::windows_core::ComInterface for IDStorageStatusArray {
            const IID: ::windows_core::GUID =
                ::windows_core::GUID::from_u128(0x82397587_7cd5_453b_a02e_31379bd64656);
        }
        #[repr(C)]
        #[doc(hidden)]
        pub struct IDStorageStatusArray_Vtbl {
            pub base__: ::windows_core::IUnknown_Vtbl,
            pub IsComplete:
                unsafe extern "system" fn(this: *mut ::core::ffi::c_void, index: u32) -> bool,
            pub GetHResult: unsafe extern "system" fn(
                this: *mut ::core::ffi::c_void,
                index: u32,
            ) -> ::windows_core::HRESULT,
        }
        pub const DSTORAGE_COMMAND_TYPE_EVENT: DSTORAGE_COMMAND_TYPE = DSTORAGE_COMMAND_TYPE(3i32);
        pub const DSTORAGE_COMMAND_TYPE_NONE: DSTORAGE_COMMAND_TYPE = DSTORAGE_COMMAND_TYPE(-1i32);
        pub const DSTORAGE_COMMAND_TYPE_REQUEST: DSTORAGE_COMMAND_TYPE =
            DSTORAGE_COMMAND_TYPE(0i32);
        pub const DSTORAGE_COMMAND_TYPE_SIGNAL: DSTORAGE_COMMAND_TYPE = DSTORAGE_COMMAND_TYPE(2i32);
        pub const DSTORAGE_COMMAND_TYPE_STATUS: DSTORAGE_COMMAND_TYPE = DSTORAGE_COMMAND_TYPE(1i32);
        pub const DSTORAGE_COMPRESSION_BEST_RATIO: DSTORAGE_COMPRESSION =
            DSTORAGE_COMPRESSION(1i32);
        pub const DSTORAGE_COMPRESSION_DEFAULT: DSTORAGE_COMPRESSION = DSTORAGE_COMPRESSION(0i32);
        pub const DSTORAGE_COMPRESSION_FASTEST: DSTORAGE_COMPRESSION = DSTORAGE_COMPRESSION(-1i32);
        pub const DSTORAGE_COMPRESSION_FORMAT_GDEFLATE: DSTORAGE_COMPRESSION_FORMAT =
            DSTORAGE_COMPRESSION_FORMAT(1u8);
        pub const DSTORAGE_COMPRESSION_FORMAT_NONE: DSTORAGE_COMPRESSION_FORMAT =
            DSTORAGE_COMPRESSION_FORMAT(0u8);
        pub const DSTORAGE_COMPRESSION_SUPPORT_CPU_FALLBACK: DSTORAGE_COMPRESSION_SUPPORT =
            DSTORAGE_COMPRESSION_SUPPORT(4u32);
        pub const DSTORAGE_COMPRESSION_SUPPORT_GPU_FALLBACK: DSTORAGE_COMPRESSION_SUPPORT =
            DSTORAGE_COMPRESSION_SUPPORT(2u32);
        pub const DSTORAGE_COMPRESSION_SUPPORT_GPU_OPTIMIZED: DSTORAGE_COMPRESSION_SUPPORT =
            DSTORAGE_COMPRESSION_SUPPORT(1u32);
        pub const DSTORAGE_COMPRESSION_SUPPORT_NONE: DSTORAGE_COMPRESSION_SUPPORT =
            DSTORAGE_COMPRESSION_SUPPORT(0u32);
        pub const DSTORAGE_COMPRESSION_SUPPORT_USES_COMPUTE_QUEUE: DSTORAGE_COMPRESSION_SUPPORT =
            DSTORAGE_COMPRESSION_SUPPORT(8u32);
        pub const DSTORAGE_COMPRESSION_SUPPORT_USES_COPY_QUEUE: DSTORAGE_COMPRESSION_SUPPORT =
            DSTORAGE_COMPRESSION_SUPPORT(16u32);
        pub const DSTORAGE_CUSTOM_COMPRESSION_0: DSTORAGE_COMPRESSION_FORMAT =
            DSTORAGE_COMPRESSION_FORMAT(128u8);
        pub const DSTORAGE_CUSTOM_DECOMPRESSION_FLAG_DEST_IN_UPLOAD_HEAP:
            DSTORAGE_CUSTOM_DECOMPRESSION_FLAGS = DSTORAGE_CUSTOM_DECOMPRESSION_FLAGS(1u32);
        pub const DSTORAGE_CUSTOM_DECOMPRESSION_FLAG_NONE: DSTORAGE_CUSTOM_DECOMPRESSION_FLAGS =
            DSTORAGE_CUSTOM_DECOMPRESSION_FLAGS(0u32);
        pub const DSTORAGE_DEBUG_BREAK_ON_ERROR: DSTORAGE_DEBUG = DSTORAGE_DEBUG(2u32);
        pub const DSTORAGE_DEBUG_NONE: DSTORAGE_DEBUG = DSTORAGE_DEBUG(0u32);
        pub const DSTORAGE_DEBUG_RECORD_OBJECT_NAMES: DSTORAGE_DEBUG = DSTORAGE_DEBUG(4u32);
        pub const DSTORAGE_DEBUG_SHOW_ERRORS: DSTORAGE_DEBUG = DSTORAGE_DEBUG(1u32);
        pub const DSTORAGE_DISABLE_BUILTIN_CPU_DECOMPRESSION: i32 = -1i32;
        pub const DSTORAGE_GET_REQUEST_FLAG_SELECT_ALL: DSTORAGE_GET_REQUEST_FLAGS =
            DSTORAGE_GET_REQUEST_FLAGS(3u32);
        pub const DSTORAGE_GET_REQUEST_FLAG_SELECT_BUILTIN: DSTORAGE_GET_REQUEST_FLAGS =
            DSTORAGE_GET_REQUEST_FLAGS(2u32);
        pub const DSTORAGE_GET_REQUEST_FLAG_SELECT_CUSTOM: DSTORAGE_GET_REQUEST_FLAGS =
            DSTORAGE_GET_REQUEST_FLAGS(1u32);
        pub const DSTORAGE_MAX_QUEUE_CAPACITY: u32 = 8192u32;
        pub const DSTORAGE_MIN_QUEUE_CAPACITY: u32 = 128u32;
        pub const DSTORAGE_PRIORITY_COUNT: DSTORAGE_PRIORITY = DSTORAGE_PRIORITY(4i8);
        pub const DSTORAGE_PRIORITY_FIRST: DSTORAGE_PRIORITY = DSTORAGE_PRIORITY(-1i8);
        pub const DSTORAGE_PRIORITY_HIGH: DSTORAGE_PRIORITY = DSTORAGE_PRIORITY(1i8);
        pub const DSTORAGE_PRIORITY_LAST: DSTORAGE_PRIORITY = DSTORAGE_PRIORITY(2i8);
        pub const DSTORAGE_PRIORITY_LOW: DSTORAGE_PRIORITY = DSTORAGE_PRIORITY(-1i8);
        pub const DSTORAGE_PRIORITY_NORMAL: DSTORAGE_PRIORITY = DSTORAGE_PRIORITY(0i8);
        pub const DSTORAGE_PRIORITY_REALTIME: DSTORAGE_PRIORITY = DSTORAGE_PRIORITY(2i8);
        pub const DSTORAGE_REQUEST_DESTINATION_BUFFER: DSTORAGE_REQUEST_DESTINATION_TYPE =
            DSTORAGE_REQUEST_DESTINATION_TYPE(1u64);
        pub const DSTORAGE_REQUEST_DESTINATION_MEMORY: DSTORAGE_REQUEST_DESTINATION_TYPE =
            DSTORAGE_REQUEST_DESTINATION_TYPE(0u64);
        pub const DSTORAGE_REQUEST_DESTINATION_MULTIPLE_SUBRESOURCES:
            DSTORAGE_REQUEST_DESTINATION_TYPE = DSTORAGE_REQUEST_DESTINATION_TYPE(3u64);
        pub const DSTORAGE_REQUEST_DESTINATION_TEXTURE_REGION: DSTORAGE_REQUEST_DESTINATION_TYPE =
            DSTORAGE_REQUEST_DESTINATION_TYPE(2u64);
        pub const DSTORAGE_REQUEST_DESTINATION_TILES: DSTORAGE_REQUEST_DESTINATION_TYPE =
            DSTORAGE_REQUEST_DESTINATION_TYPE(4u64);
        pub const DSTORAGE_REQUEST_MAX_NAME: u32 = 64u32;
        pub const DSTORAGE_REQUEST_SOURCE_FILE: DSTORAGE_REQUEST_SOURCE_TYPE =
            DSTORAGE_REQUEST_SOURCE_TYPE(0u64);
        pub const DSTORAGE_REQUEST_SOURCE_MEMORY: DSTORAGE_REQUEST_SOURCE_TYPE =
            DSTORAGE_REQUEST_SOURCE_TYPE(1u64);
        pub const DSTORAGE_SDK_VERSION: u32 = 202u32;
        pub const DSTORAGE_STAGING_BUFFER_SIZE_0: DSTORAGE_STAGING_BUFFER_SIZE =
            DSTORAGE_STAGING_BUFFER_SIZE(0u32);
        pub const DSTORAGE_STAGING_BUFFER_SIZE_32MB: DSTORAGE_STAGING_BUFFER_SIZE =
            DSTORAGE_STAGING_BUFFER_SIZE(33554432u32);
        pub const E_DSTORAGE_ACCESS_VIOLATION: ::windows_core::HRESULT =
            ::windows_core::HRESULT(-1994129399i32);
        pub const E_DSTORAGE_ALREADY_RUNNING: ::windows_core::HRESULT =
            ::windows_core::HRESULT(-1994129407i32);
        pub const E_DSTORAGE_BCPACK_BAD_DATA: ::windows_core::HRESULT =
            ::windows_core::HRESULT(-1994129355i32);
        pub const E_DSTORAGE_BCPACK_BAD_HEADER: ::windows_core::HRESULT =
            ::windows_core::HRESULT(-1994129356i32);
        pub const E_DSTORAGE_COMPRESSED_DATA_TOO_LARGE: ::windows_core::HRESULT =
            ::windows_core::HRESULT(-1994129351i32);
        pub const E_DSTORAGE_DECOMPRESSION_ERROR: ::windows_core::HRESULT =
            ::windows_core::HRESULT(-1994129360i32);
        pub const E_DSTORAGE_DECRYPTION_ERROR: ::windows_core::HRESULT =
            ::windows_core::HRESULT(-1994129354i32);
        pub const E_DSTORAGE_DEPRECATED_PREVIEW_GDK: ::windows_core::HRESULT =
            ::windows_core::HRESULT(-1994129384i32);
        pub const E_DSTORAGE_END_OF_FILE: ::windows_core::HRESULT =
            ::windows_core::HRESULT(-1994129401i32);
        pub const E_DSTORAGE_FILEBUFFERING_REQUIRES_DISABLED_BYPASSIO: ::windows_core::HRESULT =
            ::windows_core::HRESULT(-1994129343i32);
        pub const E_DSTORAGE_FILE_NOT_OPEN: ::windows_core::HRESULT =
            ::windows_core::HRESULT(-1994129397i32);
        pub const E_DSTORAGE_FILE_TOO_FRAGMENTED: ::windows_core::HRESULT =
            ::windows_core::HRESULT(-1994129352i32);
        pub const E_DSTORAGE_INDEX_BOUND: ::windows_core::HRESULT =
            ::windows_core::HRESULT(-1994129387i32);
        pub const E_DSTORAGE_INVALID_BCPACK_MODE: ::windows_core::HRESULT =
            ::windows_core::HRESULT(-1994129395i32);
        pub const E_DSTORAGE_INVALID_CLUSTER_SIZE: ::windows_core::HRESULT =
            ::windows_core::HRESULT(-1994129391i32);
        pub const E_DSTORAGE_INVALID_DESTINATION_SIZE: ::windows_core::HRESULT =
            ::windows_core::HRESULT(-1994129393i32);
        pub const E_DSTORAGE_INVALID_DESTINATION_TYPE: ::windows_core::HRESULT =
            ::windows_core::HRESULT(-1994129344i32);
        pub const E_DSTORAGE_INVALID_FENCE: ::windows_core::HRESULT =
            ::windows_core::HRESULT(-1994129374i32);
        pub const E_DSTORAGE_INVALID_FILE_HANDLE: ::windows_core::HRESULT =
            ::windows_core::HRESULT(-1994129385i32);
        pub const E_DSTORAGE_INVALID_FILE_OFFSET: ::windows_core::HRESULT =
            ::windows_core::HRESULT(-1994129382i32);
        pub const E_DSTORAGE_INVALID_INTERMEDIATE_SIZE: ::windows_core::HRESULT =
            ::windows_core::HRESULT(-1994129380i32);
        pub const E_DSTORAGE_INVALID_MEMORY_QUEUE_PRIORITY: ::windows_core::HRESULT =
            ::windows_core::HRESULT(-1994129372i32);
        pub const E_DSTORAGE_INVALID_QUEUE_CAPACITY: ::windows_core::HRESULT =
            ::windows_core::HRESULT(-1994129405i32);
        pub const E_DSTORAGE_INVALID_QUEUE_PRIORITY: ::windows_core::HRESULT =
            ::windows_core::HRESULT(-1994129389i32);
        pub const E_DSTORAGE_INVALID_SOURCE_TYPE: ::windows_core::HRESULT =
            ::windows_core::HRESULT(-1994129381i32);
        pub const E_DSTORAGE_INVALID_STAGING_BUFFER_SIZE: ::windows_core::HRESULT =
            ::windows_core::HRESULT(-1994129376i32);
        pub const E_DSTORAGE_INVALID_STATUS_ARRAY: ::windows_core::HRESULT =
            ::windows_core::HRESULT(-1994129373i32);
        pub const E_DSTORAGE_INVALID_SWIZZLE_MODE: ::windows_core::HRESULT =
            ::windows_core::HRESULT(-1994129394i32);
        pub const E_DSTORAGE_IO_TIMEOUT: ::windows_core::HRESULT =
            ::windows_core::HRESULT(-1994129386i32);
        pub const E_DSTORAGE_NOT_RUNNING: ::windows_core::HRESULT =
            ::windows_core::HRESULT(-1994129406i32);
        pub const E_DSTORAGE_PASSTHROUGH_ERROR: ::windows_core::HRESULT =
            ::windows_core::HRESULT(-1994129353i32);
        pub const E_DSTORAGE_QUEUE_CLOSED: ::windows_core::HRESULT =
            ::windows_core::HRESULT(-1994129392i32);
        pub const E_DSTORAGE_REQUEST_TOO_LARGE: ::windows_core::HRESULT =
            ::windows_core::HRESULT(-1994129400i32);
        pub const E_DSTORAGE_RESERVED_FIELDS: ::windows_core::HRESULT =
            ::windows_core::HRESULT(-1994129396i32);
        pub const E_DSTORAGE_STAGING_BUFFER_LOCKED: ::windows_core::HRESULT =
            ::windows_core::HRESULT(-1994129377i32);
        pub const E_DSTORAGE_STAGING_BUFFER_TOO_SMALL: ::windows_core::HRESULT =
            ::windows_core::HRESULT(-1994129375i32);
        pub const E_DSTORAGE_SYSTEM_NOT_SUPPORTED: ::windows_core::HRESULT =
            ::windows_core::HRESULT(-1994129379i32);
        pub const E_DSTORAGE_TOO_MANY_FILES: ::windows_core::HRESULT =
            ::windows_core::HRESULT(-1994129388i32);
        pub const E_DSTORAGE_TOO_MANY_QUEUES: ::windows_core::HRESULT =
            ::windows_core::HRESULT(-1994129390i32);
        pub const E_DSTORAGE_UNSUPPORTED_FILE: ::windows_core::HRESULT =
            ::windows_core::HRESULT(-1994129398i32);
        pub const E_DSTORAGE_UNSUPPORTED_VOLUME: ::windows_core::HRESULT =
            ::windows_core::HRESULT(-1994129403i32);
        pub const E_DSTORAGE_XVD_DEVICE_NOT_SUPPORTED: ::windows_core::HRESULT =
            ::windows_core::HRESULT(-1994129404i32);
        pub const E_DSTORAGE_XVD_NOT_REGISTERED: ::windows_core::HRESULT =
            ::windows_core::HRESULT(-1994129383i32);
        pub const E_DSTORAGE_ZLIB_BAD_DATA: ::windows_core::HRESULT =
            ::windows_core::HRESULT(-1994129358i32);
        pub const E_DSTORAGE_ZLIB_BAD_HEADER: ::windows_core::HRESULT =
            ::windows_core::HRESULT(-1994129359i32);
        pub const E_DSTORAGE_ZLIB_PARITY_FAIL: ::windows_core::HRESULT =
            ::windows_core::HRESULT(-1994129357i32);
        pub const FACILITY_GAME: u32 = 2340u32;
        #[repr(transparent)]
        #[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
        pub struct DSTORAGE_COMMAND_TYPE(pub i32);
        impl ::core::marker::Copy for DSTORAGE_COMMAND_TYPE {}
        impl ::core::clone::Clone for DSTORAGE_COMMAND_TYPE {
            fn clone(&self) -> Self {
                *self
            }
        }
        impl ::core::default::Default for DSTORAGE_COMMAND_TYPE {
            fn default() -> Self {
                Self(0)
            }
        }
        impl ::windows_core::TypeKind for DSTORAGE_COMMAND_TYPE {
            type TypeKind = ::windows_core::CopyType;
        }
        impl ::core::fmt::Debug for DSTORAGE_COMMAND_TYPE {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                f.debug_tuple("DSTORAGE_COMMAND_TYPE")
                    .field(&self.0)
                    .finish()
            }
        }
        #[repr(transparent)]
        #[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
        pub struct DSTORAGE_COMPRESSION(pub i32);
        impl ::core::marker::Copy for DSTORAGE_COMPRESSION {}
        impl ::core::clone::Clone for DSTORAGE_COMPRESSION {
            fn clone(&self) -> Self {
                *self
            }
        }
        impl ::core::default::Default for DSTORAGE_COMPRESSION {
            fn default() -> Self {
                Self(0)
            }
        }
        impl ::windows_core::TypeKind for DSTORAGE_COMPRESSION {
            type TypeKind = ::windows_core::CopyType;
        }
        impl ::core::fmt::Debug for DSTORAGE_COMPRESSION {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                f.debug_tuple("DSTORAGE_COMPRESSION")
                    .field(&self.0)
                    .finish()
            }
        }
        #[repr(transparent)]
        #[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
        pub struct DSTORAGE_COMPRESSION_FORMAT(pub u8);
        impl ::core::marker::Copy for DSTORAGE_COMPRESSION_FORMAT {}
        impl ::core::clone::Clone for DSTORAGE_COMPRESSION_FORMAT {
            fn clone(&self) -> Self {
                *self
            }
        }
        impl ::core::default::Default for DSTORAGE_COMPRESSION_FORMAT {
            fn default() -> Self {
                Self(0)
            }
        }
        impl ::windows_core::TypeKind for DSTORAGE_COMPRESSION_FORMAT {
            type TypeKind = ::windows_core::CopyType;
        }
        impl ::core::fmt::Debug for DSTORAGE_COMPRESSION_FORMAT {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                f.debug_tuple("DSTORAGE_COMPRESSION_FORMAT")
                    .field(&self.0)
                    .finish()
            }
        }
        #[repr(transparent)]
        #[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
        pub struct DSTORAGE_COMPRESSION_SUPPORT(pub u32);
        impl ::core::marker::Copy for DSTORAGE_COMPRESSION_SUPPORT {}
        impl ::core::clone::Clone for DSTORAGE_COMPRESSION_SUPPORT {
            fn clone(&self) -> Self {
                *self
            }
        }
        impl ::core::default::Default for DSTORAGE_COMPRESSION_SUPPORT {
            fn default() -> Self {
                Self(0)
            }
        }
        impl ::windows_core::TypeKind for DSTORAGE_COMPRESSION_SUPPORT {
            type TypeKind = ::windows_core::CopyType;
        }
        impl ::core::fmt::Debug for DSTORAGE_COMPRESSION_SUPPORT {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                f.debug_tuple("DSTORAGE_COMPRESSION_SUPPORT")
                    .field(&self.0)
                    .finish()
            }
        }
        impl DSTORAGE_COMPRESSION_SUPPORT {
            pub const fn contains(&self, other: Self) -> bool {
                self.0 & other.0 == other.0
            }
        }
        impl ::core::ops::BitOr for DSTORAGE_COMPRESSION_SUPPORT {
            type Output = Self;
            fn bitor(self, other: Self) -> Self {
                Self(self.0 | other.0)
            }
        }
        impl ::core::ops::BitAnd for DSTORAGE_COMPRESSION_SUPPORT {
            type Output = Self;
            fn bitand(self, other: Self) -> Self {
                Self(self.0 & other.0)
            }
        }
        impl ::core::ops::BitOrAssign for DSTORAGE_COMPRESSION_SUPPORT {
            fn bitor_assign(&mut self, other: Self) {
                self.0.bitor_assign(other.0)
            }
        }
        impl ::core::ops::BitAndAssign for DSTORAGE_COMPRESSION_SUPPORT {
            fn bitand_assign(&mut self, other: Self) {
                self.0.bitand_assign(other.0)
            }
        }
        impl ::core::ops::Not for DSTORAGE_COMPRESSION_SUPPORT {
            type Output = Self;
            fn not(self) -> Self {
                Self(self.0.not())
            }
        }
        #[repr(transparent)]
        #[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
        pub struct DSTORAGE_CUSTOM_DECOMPRESSION_FLAGS(pub u32);
        impl ::core::marker::Copy for DSTORAGE_CUSTOM_DECOMPRESSION_FLAGS {}
        impl ::core::clone::Clone for DSTORAGE_CUSTOM_DECOMPRESSION_FLAGS {
            fn clone(&self) -> Self {
                *self
            }
        }
        impl ::core::default::Default for DSTORAGE_CUSTOM_DECOMPRESSION_FLAGS {
            fn default() -> Self {
                Self(0)
            }
        }
        impl ::windows_core::TypeKind for DSTORAGE_CUSTOM_DECOMPRESSION_FLAGS {
            type TypeKind = ::windows_core::CopyType;
        }
        impl ::core::fmt::Debug for DSTORAGE_CUSTOM_DECOMPRESSION_FLAGS {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                f.debug_tuple("DSTORAGE_CUSTOM_DECOMPRESSION_FLAGS")
                    .field(&self.0)
                    .finish()
            }
        }
        impl DSTORAGE_CUSTOM_DECOMPRESSION_FLAGS {
            pub const fn contains(&self, other: Self) -> bool {
                self.0 & other.0 == other.0
            }
        }
        impl ::core::ops::BitOr for DSTORAGE_CUSTOM_DECOMPRESSION_FLAGS {
            type Output = Self;
            fn bitor(self, other: Self) -> Self {
                Self(self.0 | other.0)
            }
        }
        impl ::core::ops::BitAnd for DSTORAGE_CUSTOM_DECOMPRESSION_FLAGS {
            type Output = Self;
            fn bitand(self, other: Self) -> Self {
                Self(self.0 & other.0)
            }
        }
        impl ::core::ops::BitOrAssign for DSTORAGE_CUSTOM_DECOMPRESSION_FLAGS {
            fn bitor_assign(&mut self, other: Self) {
                self.0.bitor_assign(other.0)
            }
        }
        impl ::core::ops::BitAndAssign for DSTORAGE_CUSTOM_DECOMPRESSION_FLAGS {
            fn bitand_assign(&mut self, other: Self) {
                self.0.bitand_assign(other.0)
            }
        }
        impl ::core::ops::Not for DSTORAGE_CUSTOM_DECOMPRESSION_FLAGS {
            type Output = Self;
            fn not(self) -> Self {
                Self(self.0.not())
            }
        }
        #[repr(transparent)]
        #[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
        pub struct DSTORAGE_DEBUG(pub u32);
        impl ::core::marker::Copy for DSTORAGE_DEBUG {}
        impl ::core::clone::Clone for DSTORAGE_DEBUG {
            fn clone(&self) -> Self {
                *self
            }
        }
        impl ::core::default::Default for DSTORAGE_DEBUG {
            fn default() -> Self {
                Self(0)
            }
        }
        impl ::windows_core::TypeKind for DSTORAGE_DEBUG {
            type TypeKind = ::windows_core::CopyType;
        }
        impl ::core::fmt::Debug for DSTORAGE_DEBUG {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                f.debug_tuple("DSTORAGE_DEBUG").field(&self.0).finish()
            }
        }
        impl DSTORAGE_DEBUG {
            pub const fn contains(&self, other: Self) -> bool {
                self.0 & other.0 == other.0
            }
        }
        impl ::core::ops::BitOr for DSTORAGE_DEBUG {
            type Output = Self;
            fn bitor(self, other: Self) -> Self {
                Self(self.0 | other.0)
            }
        }
        impl ::core::ops::BitAnd for DSTORAGE_DEBUG {
            type Output = Self;
            fn bitand(self, other: Self) -> Self {
                Self(self.0 & other.0)
            }
        }
        impl ::core::ops::BitOrAssign for DSTORAGE_DEBUG {
            fn bitor_assign(&mut self, other: Self) {
                self.0.bitor_assign(other.0)
            }
        }
        impl ::core::ops::BitAndAssign for DSTORAGE_DEBUG {
            fn bitand_assign(&mut self, other: Self) {
                self.0.bitand_assign(other.0)
            }
        }
        impl ::core::ops::Not for DSTORAGE_DEBUG {
            type Output = Self;
            fn not(self) -> Self {
                Self(self.0.not())
            }
        }
        #[repr(transparent)]
        #[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
        pub struct DSTORAGE_GET_REQUEST_FLAGS(pub u32);
        impl ::core::marker::Copy for DSTORAGE_GET_REQUEST_FLAGS {}
        impl ::core::clone::Clone for DSTORAGE_GET_REQUEST_FLAGS {
            fn clone(&self) -> Self {
                *self
            }
        }
        impl ::core::default::Default for DSTORAGE_GET_REQUEST_FLAGS {
            fn default() -> Self {
                Self(0)
            }
        }
        impl ::windows_core::TypeKind for DSTORAGE_GET_REQUEST_FLAGS {
            type TypeKind = ::windows_core::CopyType;
        }
        impl ::core::fmt::Debug for DSTORAGE_GET_REQUEST_FLAGS {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                f.debug_tuple("DSTORAGE_GET_REQUEST_FLAGS")
                    .field(&self.0)
                    .finish()
            }
        }
        impl DSTORAGE_GET_REQUEST_FLAGS {
            pub const fn contains(&self, other: Self) -> bool {
                self.0 & other.0 == other.0
            }
        }
        impl ::core::ops::BitOr for DSTORAGE_GET_REQUEST_FLAGS {
            type Output = Self;
            fn bitor(self, other: Self) -> Self {
                Self(self.0 | other.0)
            }
        }
        impl ::core::ops::BitAnd for DSTORAGE_GET_REQUEST_FLAGS {
            type Output = Self;
            fn bitand(self, other: Self) -> Self {
                Self(self.0 & other.0)
            }
        }
        impl ::core::ops::BitOrAssign for DSTORAGE_GET_REQUEST_FLAGS {
            fn bitor_assign(&mut self, other: Self) {
                self.0.bitor_assign(other.0)
            }
        }
        impl ::core::ops::BitAndAssign for DSTORAGE_GET_REQUEST_FLAGS {
            fn bitand_assign(&mut self, other: Self) {
                self.0.bitand_assign(other.0)
            }
        }
        impl ::core::ops::Not for DSTORAGE_GET_REQUEST_FLAGS {
            type Output = Self;
            fn not(self) -> Self {
                Self(self.0.not())
            }
        }
        #[repr(transparent)]
        #[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
        pub struct DSTORAGE_PRIORITY(pub i8);
        impl ::core::marker::Copy for DSTORAGE_PRIORITY {}
        impl ::core::clone::Clone for DSTORAGE_PRIORITY {
            fn clone(&self) -> Self {
                *self
            }
        }
        impl ::core::default::Default for DSTORAGE_PRIORITY {
            fn default() -> Self {
                Self(0)
            }
        }
        impl ::windows_core::TypeKind for DSTORAGE_PRIORITY {
            type TypeKind = ::windows_core::CopyType;
        }
        impl ::core::fmt::Debug for DSTORAGE_PRIORITY {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                f.debug_tuple("DSTORAGE_PRIORITY").field(&self.0).finish()
            }
        }
        #[repr(transparent)]
        #[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
        pub struct DSTORAGE_REQUEST_DESTINATION_TYPE(pub u64);
        impl ::core::marker::Copy for DSTORAGE_REQUEST_DESTINATION_TYPE {}
        impl ::core::clone::Clone for DSTORAGE_REQUEST_DESTINATION_TYPE {
            fn clone(&self) -> Self {
                *self
            }
        }
        impl ::core::default::Default for DSTORAGE_REQUEST_DESTINATION_TYPE {
            fn default() -> Self {
                Self(0)
            }
        }
        impl ::windows_core::TypeKind for DSTORAGE_REQUEST_DESTINATION_TYPE {
            type TypeKind = ::windows_core::CopyType;
        }
        impl ::core::fmt::Debug for DSTORAGE_REQUEST_DESTINATION_TYPE {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                f.debug_tuple("DSTORAGE_REQUEST_DESTINATION_TYPE")
                    .field(&self.0)
                    .finish()
            }
        }
        #[repr(transparent)]
        #[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
        pub struct DSTORAGE_REQUEST_SOURCE_TYPE(pub u64);
        impl ::core::marker::Copy for DSTORAGE_REQUEST_SOURCE_TYPE {}
        impl ::core::clone::Clone for DSTORAGE_REQUEST_SOURCE_TYPE {
            fn clone(&self) -> Self {
                *self
            }
        }
        impl ::core::default::Default for DSTORAGE_REQUEST_SOURCE_TYPE {
            fn default() -> Self {
                Self(0)
            }
        }
        impl ::windows_core::TypeKind for DSTORAGE_REQUEST_SOURCE_TYPE {
            type TypeKind = ::windows_core::CopyType;
        }
        impl ::core::fmt::Debug for DSTORAGE_REQUEST_SOURCE_TYPE {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                f.debug_tuple("DSTORAGE_REQUEST_SOURCE_TYPE")
                    .field(&self.0)
                    .finish()
            }
        }
        #[repr(transparent)]
        #[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
        pub struct DSTORAGE_STAGING_BUFFER_SIZE(pub u32);
        impl ::core::marker::Copy for DSTORAGE_STAGING_BUFFER_SIZE {}
        impl ::core::clone::Clone for DSTORAGE_STAGING_BUFFER_SIZE {
            fn clone(&self) -> Self {
                *self
            }
        }
        impl ::core::default::Default for DSTORAGE_STAGING_BUFFER_SIZE {
            fn default() -> Self {
                Self(0)
            }
        }
        impl ::windows_core::TypeKind for DSTORAGE_STAGING_BUFFER_SIZE {
            type TypeKind = ::windows_core::CopyType;
        }
        impl ::core::fmt::Debug for DSTORAGE_STAGING_BUFFER_SIZE {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                f.debug_tuple("DSTORAGE_STAGING_BUFFER_SIZE")
                    .field(&self.0)
                    .finish()
            }
        }
        #[repr(C)]
        pub struct DSTORAGE_CONFIGURATION {
            pub NumSubmitThreads: u32,
            pub NumBuiltInCpuDecompressionThreads: i32,
            pub ForceMappingLayer: ::windows::Win32::Foundation::BOOL,
            pub DisableBypassIO: ::windows::Win32::Foundation::BOOL,
            pub DisableTelemetry: ::windows::Win32::Foundation::BOOL,
            pub DisableGpuDecompressionMetacommand: ::windows::Win32::Foundation::BOOL,
            pub DisableGpuDecompression: ::windows::Win32::Foundation::BOOL,
        }
        impl ::core::marker::Copy for DSTORAGE_CONFIGURATION {}
        impl ::core::clone::Clone for DSTORAGE_CONFIGURATION {
            fn clone(&self) -> Self {
                *self
            }
        }
        impl ::core::fmt::Debug for DSTORAGE_CONFIGURATION {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                f.debug_struct("DSTORAGE_CONFIGURATION")
                    .field("NumSubmitThreads", &self.NumSubmitThreads)
                    .field(
                        "NumBuiltInCpuDecompressionThreads",
                        &self.NumBuiltInCpuDecompressionThreads,
                    )
                    .field("ForceMappingLayer", &self.ForceMappingLayer)
                    .field("DisableBypassIO", &self.DisableBypassIO)
                    .field("DisableTelemetry", &self.DisableTelemetry)
                    .field(
                        "DisableGpuDecompressionMetacommand",
                        &self.DisableGpuDecompressionMetacommand,
                    )
                    .field("DisableGpuDecompression", &self.DisableGpuDecompression)
                    .finish()
            }
        }
        impl ::windows_core::TypeKind for DSTORAGE_CONFIGURATION {
            type TypeKind = ::windows_core::CopyType;
        }
        impl ::core::cmp::PartialEq for DSTORAGE_CONFIGURATION {
            fn eq(&self, other: &Self) -> bool {
                self.NumSubmitThreads == other.NumSubmitThreads
                    && self.NumBuiltInCpuDecompressionThreads
                        == other.NumBuiltInCpuDecompressionThreads
                    && self.ForceMappingLayer == other.ForceMappingLayer
                    && self.DisableBypassIO == other.DisableBypassIO
                    && self.DisableTelemetry == other.DisableTelemetry
                    && self.DisableGpuDecompressionMetacommand
                        == other.DisableGpuDecompressionMetacommand
                    && self.DisableGpuDecompression == other.DisableGpuDecompression
            }
        }
        impl ::core::cmp::Eq for DSTORAGE_CONFIGURATION {}
        impl ::core::default::Default for DSTORAGE_CONFIGURATION {
            fn default() -> Self {
                unsafe { ::core::mem::zeroed() }
            }
        }
        #[repr(C)]
        pub struct DSTORAGE_CONFIGURATION1 {
            pub NumSubmitThreads: u32,
            pub NumBuiltInCpuDecompressionThreads: i32,
            pub ForceMappingLayer: ::windows::Win32::Foundation::BOOL,
            pub DisableBypassIO: ::windows::Win32::Foundation::BOOL,
            pub DisableTelemetry: ::windows::Win32::Foundation::BOOL,
            pub DisableGpuDecompressionMetacommand: ::windows::Win32::Foundation::BOOL,
            pub DisableGpuDecompression: ::windows::Win32::Foundation::BOOL,
            pub ForceFileBuffering: ::windows::Win32::Foundation::BOOL,
        }
        impl ::core::marker::Copy for DSTORAGE_CONFIGURATION1 {}
        impl ::core::clone::Clone for DSTORAGE_CONFIGURATION1 {
            fn clone(&self) -> Self {
                *self
            }
        }
        impl ::core::fmt::Debug for DSTORAGE_CONFIGURATION1 {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                f.debug_struct("DSTORAGE_CONFIGURATION1")
                    .field("NumSubmitThreads", &self.NumSubmitThreads)
                    .field(
                        "NumBuiltInCpuDecompressionThreads",
                        &self.NumBuiltInCpuDecompressionThreads,
                    )
                    .field("ForceMappingLayer", &self.ForceMappingLayer)
                    .field("DisableBypassIO", &self.DisableBypassIO)
                    .field("DisableTelemetry", &self.DisableTelemetry)
                    .field(
                        "DisableGpuDecompressionMetacommand",
                        &self.DisableGpuDecompressionMetacommand,
                    )
                    .field("DisableGpuDecompression", &self.DisableGpuDecompression)
                    .field("ForceFileBuffering", &self.ForceFileBuffering)
                    .finish()
            }
        }
        impl ::windows_core::TypeKind for DSTORAGE_CONFIGURATION1 {
            type TypeKind = ::windows_core::CopyType;
        }
        impl ::core::cmp::PartialEq for DSTORAGE_CONFIGURATION1 {
            fn eq(&self, other: &Self) -> bool {
                self.NumSubmitThreads == other.NumSubmitThreads
                    && self.NumBuiltInCpuDecompressionThreads
                        == other.NumBuiltInCpuDecompressionThreads
                    && self.ForceMappingLayer == other.ForceMappingLayer
                    && self.DisableBypassIO == other.DisableBypassIO
                    && self.DisableTelemetry == other.DisableTelemetry
                    && self.DisableGpuDecompressionMetacommand
                        == other.DisableGpuDecompressionMetacommand
                    && self.DisableGpuDecompression == other.DisableGpuDecompression
                    && self.ForceFileBuffering == other.ForceFileBuffering
            }
        }
        impl ::core::cmp::Eq for DSTORAGE_CONFIGURATION1 {}
        impl ::core::default::Default for DSTORAGE_CONFIGURATION1 {
            fn default() -> Self {
                unsafe { ::core::mem::zeroed() }
            }
        }
        #[repr(C)]
        pub struct DSTORAGE_CUSTOM_DECOMPRESSION_REQUEST {
            pub Id: u64,
            pub CompressionFormat: DSTORAGE_COMPRESSION_FORMAT,
            pub Reserved: [u8; 3],
            pub Flags: DSTORAGE_CUSTOM_DECOMPRESSION_FLAGS,
            pub SrcSize: u64,
            pub SrcBuffer: *const ::core::ffi::c_void,
            pub DstSize: u64,
            pub DstBuffer: *mut ::core::ffi::c_void,
        }
        impl ::core::marker::Copy for DSTORAGE_CUSTOM_DECOMPRESSION_REQUEST {}
        impl ::core::clone::Clone for DSTORAGE_CUSTOM_DECOMPRESSION_REQUEST {
            fn clone(&self) -> Self {
                *self
            }
        }
        impl ::core::fmt::Debug for DSTORAGE_CUSTOM_DECOMPRESSION_REQUEST {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                f.debug_struct("DSTORAGE_CUSTOM_DECOMPRESSION_REQUEST")
                    .field("Id", &self.Id)
                    .field("CompressionFormat", &self.CompressionFormat)
                    .field("Reserved", &self.Reserved)
                    .field("Flags", &self.Flags)
                    .field("SrcSize", &self.SrcSize)
                    .field("SrcBuffer", &self.SrcBuffer)
                    .field("DstSize", &self.DstSize)
                    .field("DstBuffer", &self.DstBuffer)
                    .finish()
            }
        }
        impl ::windows_core::TypeKind for DSTORAGE_CUSTOM_DECOMPRESSION_REQUEST {
            type TypeKind = ::windows_core::CopyType;
        }
        impl ::core::cmp::PartialEq for DSTORAGE_CUSTOM_DECOMPRESSION_REQUEST {
            fn eq(&self, other: &Self) -> bool {
                self.Id == other.Id
                    && self.CompressionFormat == other.CompressionFormat
                    && self.Reserved == other.Reserved
                    && self.Flags == other.Flags
                    && self.SrcSize == other.SrcSize
                    && self.SrcBuffer == other.SrcBuffer
                    && self.DstSize == other.DstSize
                    && self.DstBuffer == other.DstBuffer
            }
        }
        impl ::core::cmp::Eq for DSTORAGE_CUSTOM_DECOMPRESSION_REQUEST {}
        impl ::core::default::Default for DSTORAGE_CUSTOM_DECOMPRESSION_REQUEST {
            fn default() -> Self {
                unsafe { ::core::mem::zeroed() }
            }
        }
        #[repr(C)]
        pub struct DSTORAGE_CUSTOM_DECOMPRESSION_RESULT {
            pub Id: u64,
            pub Result: ::windows_core::HRESULT,
        }
        impl ::core::marker::Copy for DSTORAGE_CUSTOM_DECOMPRESSION_RESULT {}
        impl ::core::clone::Clone for DSTORAGE_CUSTOM_DECOMPRESSION_RESULT {
            fn clone(&self) -> Self {
                *self
            }
        }
        impl ::core::fmt::Debug for DSTORAGE_CUSTOM_DECOMPRESSION_RESULT {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                f.debug_struct("DSTORAGE_CUSTOM_DECOMPRESSION_RESULT")
                    .field("Id", &self.Id)
                    .field("Result", &self.Result)
                    .finish()
            }
        }
        impl ::windows_core::TypeKind for DSTORAGE_CUSTOM_DECOMPRESSION_RESULT {
            type TypeKind = ::windows_core::CopyType;
        }
        impl ::core::cmp::PartialEq for DSTORAGE_CUSTOM_DECOMPRESSION_RESULT {
            fn eq(&self, other: &Self) -> bool {
                self.Id == other.Id && self.Result == other.Result
            }
        }
        impl ::core::cmp::Eq for DSTORAGE_CUSTOM_DECOMPRESSION_RESULT {}
        impl ::core::default::Default for DSTORAGE_CUSTOM_DECOMPRESSION_RESULT {
            fn default() -> Self {
                unsafe { ::core::mem::zeroed() }
            }
        }
        #[repr(C)]
        pub union DSTORAGE_DESTINATION {
            pub Memory: DSTORAGE_DESTINATION_MEMORY,
            pub Buffer: ::std::mem::ManuallyDrop<DSTORAGE_DESTINATION_BUFFER>,
            pub Texture: ::std::mem::ManuallyDrop<DSTORAGE_DESTINATION_TEXTURE_REGION>,
            pub MultipleSubresources:
                ::std::mem::ManuallyDrop<DSTORAGE_DESTINATION_MULTIPLE_SUBRESOURCES>,
            pub Tiles: ::std::mem::ManuallyDrop<DSTORAGE_DESTINATION_TILES>,
        }
        impl ::core::clone::Clone for DSTORAGE_DESTINATION {
            fn clone(&self) -> Self {
                unsafe { ::core::mem::transmute_copy(self) }
            }
        }
        impl ::windows_core::TypeKind for DSTORAGE_DESTINATION {
            type TypeKind = ::windows_core::CopyType;
        }
        impl ::core::default::Default for DSTORAGE_DESTINATION {
            fn default() -> Self {
                unsafe { ::core::mem::zeroed() }
            }
        }
        #[repr(C)]
        pub struct DSTORAGE_DESTINATION_BUFFER {
            pub Resource: ::std::mem::ManuallyDrop<
                ::core::option::Option<::windows::Win32::Graphics::Direct3D12::ID3D12Resource>,
            >,
            pub Offset: u64,
            pub Size: u32,
        }
        impl ::core::clone::Clone for DSTORAGE_DESTINATION_BUFFER {
            fn clone(&self) -> Self {
                unsafe { ::core::mem::transmute_copy(self) }
            }
        }
        impl ::core::fmt::Debug for DSTORAGE_DESTINATION_BUFFER {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                f.debug_struct("DSTORAGE_DESTINATION_BUFFER")
                    .field("Resource", &self.Resource)
                    .field("Offset", &self.Offset)
                    .field("Size", &self.Size)
                    .finish()
            }
        }
        impl ::windows_core::TypeKind for DSTORAGE_DESTINATION_BUFFER {
            type TypeKind = ::windows_core::CopyType;
        }
        impl ::core::cmp::PartialEq for DSTORAGE_DESTINATION_BUFFER {
            fn eq(&self, other: &Self) -> bool {
                self.Resource == other.Resource
                    && self.Offset == other.Offset
                    && self.Size == other.Size
            }
        }
        impl ::core::cmp::Eq for DSTORAGE_DESTINATION_BUFFER {}
        impl ::core::default::Default for DSTORAGE_DESTINATION_BUFFER {
            fn default() -> Self {
                unsafe { ::core::mem::zeroed() }
            }
        }
        #[repr(C)]
        pub struct DSTORAGE_DESTINATION_MEMORY {
            pub Buffer: *mut ::core::ffi::c_void,
            pub Size: u32,
        }
        impl ::core::marker::Copy for DSTORAGE_DESTINATION_MEMORY {}
        impl ::core::clone::Clone for DSTORAGE_DESTINATION_MEMORY {
            fn clone(&self) -> Self {
                *self
            }
        }
        impl ::core::fmt::Debug for DSTORAGE_DESTINATION_MEMORY {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                f.debug_struct("DSTORAGE_DESTINATION_MEMORY")
                    .field("Buffer", &self.Buffer)
                    .field("Size", &self.Size)
                    .finish()
            }
        }
        impl ::windows_core::TypeKind for DSTORAGE_DESTINATION_MEMORY {
            type TypeKind = ::windows_core::CopyType;
        }
        impl ::core::cmp::PartialEq for DSTORAGE_DESTINATION_MEMORY {
            fn eq(&self, other: &Self) -> bool {
                self.Buffer == other.Buffer && self.Size == other.Size
            }
        }
        impl ::core::cmp::Eq for DSTORAGE_DESTINATION_MEMORY {}
        impl ::core::default::Default for DSTORAGE_DESTINATION_MEMORY {
            fn default() -> Self {
                unsafe { ::core::mem::zeroed() }
            }
        }
        #[repr(C)]
        pub struct DSTORAGE_DESTINATION_MULTIPLE_SUBRESOURCES {
            pub Resource: ::std::mem::ManuallyDrop<
                ::core::option::Option<::windows::Win32::Graphics::Direct3D12::ID3D12Resource>,
            >,
            pub FirstSubresource: u32,
        }
        impl ::core::clone::Clone for DSTORAGE_DESTINATION_MULTIPLE_SUBRESOURCES {
            fn clone(&self) -> Self {
                unsafe { ::core::mem::transmute_copy(self) }
            }
        }
        impl ::core::fmt::Debug for DSTORAGE_DESTINATION_MULTIPLE_SUBRESOURCES {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                f.debug_struct("DSTORAGE_DESTINATION_MULTIPLE_SUBRESOURCES")
                    .field("Resource", &self.Resource)
                    .field("FirstSubresource", &self.FirstSubresource)
                    .finish()
            }
        }
        impl ::windows_core::TypeKind for DSTORAGE_DESTINATION_MULTIPLE_SUBRESOURCES {
            type TypeKind = ::windows_core::CopyType;
        }
        impl ::core::cmp::PartialEq for DSTORAGE_DESTINATION_MULTIPLE_SUBRESOURCES {
            fn eq(&self, other: &Self) -> bool {
                self.Resource == other.Resource && self.FirstSubresource == other.FirstSubresource
            }
        }
        impl ::core::cmp::Eq for DSTORAGE_DESTINATION_MULTIPLE_SUBRESOURCES {}
        impl ::core::default::Default for DSTORAGE_DESTINATION_MULTIPLE_SUBRESOURCES {
            fn default() -> Self {
                unsafe { ::core::mem::zeroed() }
            }
        }
        #[repr(C)]
        pub struct DSTORAGE_DESTINATION_TEXTURE_REGION {
            pub Resource: ::std::mem::ManuallyDrop<
                ::core::option::Option<::windows::Win32::Graphics::Direct3D12::ID3D12Resource>,
            >,
            pub SubresourceIndex: u32,
            pub Region: ::windows::Win32::Graphics::Direct3D12::D3D12_BOX,
        }
        impl ::core::clone::Clone for DSTORAGE_DESTINATION_TEXTURE_REGION {
            fn clone(&self) -> Self {
                unsafe { ::core::mem::transmute_copy(self) }
            }
        }
        impl ::core::fmt::Debug for DSTORAGE_DESTINATION_TEXTURE_REGION {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                f.debug_struct("DSTORAGE_DESTINATION_TEXTURE_REGION")
                    .field("Resource", &self.Resource)
                    .field("SubresourceIndex", &self.SubresourceIndex)
                    .field("Region", &self.Region)
                    .finish()
            }
        }
        impl ::windows_core::TypeKind for DSTORAGE_DESTINATION_TEXTURE_REGION {
            type TypeKind = ::windows_core::CopyType;
        }
        impl ::core::cmp::PartialEq for DSTORAGE_DESTINATION_TEXTURE_REGION {
            fn eq(&self, other: &Self) -> bool {
                self.Resource == other.Resource
                    && self.SubresourceIndex == other.SubresourceIndex
                    && self.Region == other.Region
            }
        }
        impl ::core::cmp::Eq for DSTORAGE_DESTINATION_TEXTURE_REGION {}
        impl ::core::default::Default for DSTORAGE_DESTINATION_TEXTURE_REGION {
            fn default() -> Self {
                unsafe { ::core::mem::zeroed() }
            }
        }
        #[repr(C)]
        pub struct DSTORAGE_DESTINATION_TILES {
            pub Resource: ::std::mem::ManuallyDrop<
                ::core::option::Option<::windows::Win32::Graphics::Direct3D12::ID3D12Resource>,
            >,
            pub TiledRegionStartCoordinate:
                ::windows::Win32::Graphics::Direct3D12::D3D12_TILED_RESOURCE_COORDINATE,
            pub TileRegionSize: ::windows::Win32::Graphics::Direct3D12::D3D12_TILE_REGION_SIZE,
        }
        impl ::core::clone::Clone for DSTORAGE_DESTINATION_TILES {
            fn clone(&self) -> Self {
                unsafe { ::core::mem::transmute_copy(self) }
            }
        }
        impl ::core::fmt::Debug for DSTORAGE_DESTINATION_TILES {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                f.debug_struct("DSTORAGE_DESTINATION_TILES")
                    .field("Resource", &self.Resource)
                    .field(
                        "TiledRegionStartCoordinate",
                        &self.TiledRegionStartCoordinate,
                    )
                    .field("TileRegionSize", &self.TileRegionSize)
                    .finish()
            }
        }
        impl ::windows_core::TypeKind for DSTORAGE_DESTINATION_TILES {
            type TypeKind = ::windows_core::CopyType;
        }
        impl ::core::cmp::PartialEq for DSTORAGE_DESTINATION_TILES {
            fn eq(&self, other: &Self) -> bool {
                self.Resource == other.Resource
                    && self.TiledRegionStartCoordinate == other.TiledRegionStartCoordinate
                    && self.TileRegionSize == other.TileRegionSize
            }
        }
        impl ::core::cmp::Eq for DSTORAGE_DESTINATION_TILES {}
        impl ::core::default::Default for DSTORAGE_DESTINATION_TILES {
            fn default() -> Self {
                unsafe { ::core::mem::zeroed() }
            }
        }
        #[repr(C)]
        pub struct DSTORAGE_ERROR_FIRST_FAILURE {
            pub HResult: ::windows_core::HRESULT,
            pub CommandType: DSTORAGE_COMMAND_TYPE,
            pub Anonymous: DSTORAGE_ERROR_FIRST_FAILURE_0,
        }
        impl ::core::clone::Clone for DSTORAGE_ERROR_FIRST_FAILURE {
            fn clone(&self) -> Self {
                unsafe { ::core::mem::transmute_copy(self) }
            }
        }
        impl ::windows_core::TypeKind for DSTORAGE_ERROR_FIRST_FAILURE {
            type TypeKind = ::windows_core::CopyType;
        }
        impl ::core::default::Default for DSTORAGE_ERROR_FIRST_FAILURE {
            fn default() -> Self {
                unsafe { ::core::mem::zeroed() }
            }
        }
        #[repr(C)]
        pub union DSTORAGE_ERROR_FIRST_FAILURE_0 {
            pub Request: ::std::mem::ManuallyDrop<DSTORAGE_ERROR_PARAMETERS_REQUEST>,
            pub Status: ::std::mem::ManuallyDrop<DSTORAGE_ERROR_PARAMETERS_STATUS>,
            pub Signal: ::std::mem::ManuallyDrop<DSTORAGE_ERROR_PARAMETERS_SIGNAL>,
            pub Event: DSTORAGE_ERROR_PARAMETERS_EVENT,
        }
        impl ::core::clone::Clone for DSTORAGE_ERROR_FIRST_FAILURE_0 {
            fn clone(&self) -> Self {
                unsafe { ::core::mem::transmute_copy(self) }
            }
        }
        impl ::windows_core::TypeKind for DSTORAGE_ERROR_FIRST_FAILURE_0 {
            type TypeKind = ::windows_core::CopyType;
        }
        impl ::core::default::Default for DSTORAGE_ERROR_FIRST_FAILURE_0 {
            fn default() -> Self {
                unsafe { ::core::mem::zeroed() }
            }
        }
        #[repr(C)]
        pub struct DSTORAGE_ERROR_PARAMETERS_EVENT {
            pub Handle: ::windows::Win32::Foundation::HANDLE,
        }
        impl ::core::marker::Copy for DSTORAGE_ERROR_PARAMETERS_EVENT {}
        impl ::core::clone::Clone for DSTORAGE_ERROR_PARAMETERS_EVENT {
            fn clone(&self) -> Self {
                *self
            }
        }
        impl ::core::fmt::Debug for DSTORAGE_ERROR_PARAMETERS_EVENT {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                f.debug_struct("DSTORAGE_ERROR_PARAMETERS_EVENT")
                    .field("Handle", &self.Handle)
                    .finish()
            }
        }
        impl ::windows_core::TypeKind for DSTORAGE_ERROR_PARAMETERS_EVENT {
            type TypeKind = ::windows_core::CopyType;
        }
        impl ::core::cmp::PartialEq for DSTORAGE_ERROR_PARAMETERS_EVENT {
            fn eq(&self, other: &Self) -> bool {
                self.Handle == other.Handle
            }
        }
        impl ::core::cmp::Eq for DSTORAGE_ERROR_PARAMETERS_EVENT {}
        impl ::core::default::Default for DSTORAGE_ERROR_PARAMETERS_EVENT {
            fn default() -> Self {
                unsafe { ::core::mem::zeroed() }
            }
        }
        #[repr(C)]
        pub struct DSTORAGE_ERROR_PARAMETERS_REQUEST {
            pub Filename: [u16; 260],
            pub RequestName: [u8; 64],
            pub Request: DSTORAGE_REQUEST,
        }
        impl ::core::clone::Clone for DSTORAGE_ERROR_PARAMETERS_REQUEST {
            fn clone(&self) -> Self {
                unsafe { ::core::mem::transmute_copy(self) }
            }
        }
        impl ::windows_core::TypeKind for DSTORAGE_ERROR_PARAMETERS_REQUEST {
            type TypeKind = ::windows_core::CopyType;
        }
        impl ::core::default::Default for DSTORAGE_ERROR_PARAMETERS_REQUEST {
            fn default() -> Self {
                unsafe { ::core::mem::zeroed() }
            }
        }
        #[repr(C)]
        pub struct DSTORAGE_ERROR_PARAMETERS_SIGNAL {
            pub Fence: ::std::mem::ManuallyDrop<
                ::core::option::Option<::windows::Win32::Graphics::Direct3D12::ID3D12Fence>,
            >,
            pub Value: u64,
        }
        impl ::core::clone::Clone for DSTORAGE_ERROR_PARAMETERS_SIGNAL {
            fn clone(&self) -> Self {
                unsafe { ::core::mem::transmute_copy(self) }
            }
        }
        impl ::core::fmt::Debug for DSTORAGE_ERROR_PARAMETERS_SIGNAL {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                f.debug_struct("DSTORAGE_ERROR_PARAMETERS_SIGNAL")
                    .field("Fence", &self.Fence)
                    .field("Value", &self.Value)
                    .finish()
            }
        }
        impl ::windows_core::TypeKind for DSTORAGE_ERROR_PARAMETERS_SIGNAL {
            type TypeKind = ::windows_core::CopyType;
        }
        impl ::core::cmp::PartialEq for DSTORAGE_ERROR_PARAMETERS_SIGNAL {
            fn eq(&self, other: &Self) -> bool {
                self.Fence == other.Fence && self.Value == other.Value
            }
        }
        impl ::core::cmp::Eq for DSTORAGE_ERROR_PARAMETERS_SIGNAL {}
        impl ::core::default::Default for DSTORAGE_ERROR_PARAMETERS_SIGNAL {
            fn default() -> Self {
                unsafe { ::core::mem::zeroed() }
            }
        }
        #[repr(C)]
        pub struct DSTORAGE_ERROR_PARAMETERS_STATUS {
            pub StatusArray: ::std::mem::ManuallyDrop<::core::option::Option<IDStorageStatusArray>>,
            pub Index: u32,
        }
        impl ::core::clone::Clone for DSTORAGE_ERROR_PARAMETERS_STATUS {
            fn clone(&self) -> Self {
                unsafe { ::core::mem::transmute_copy(self) }
            }
        }
        impl ::core::fmt::Debug for DSTORAGE_ERROR_PARAMETERS_STATUS {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                f.debug_struct("DSTORAGE_ERROR_PARAMETERS_STATUS")
                    .field("StatusArray", &self.StatusArray)
                    .field("Index", &self.Index)
                    .finish()
            }
        }
        impl ::windows_core::TypeKind for DSTORAGE_ERROR_PARAMETERS_STATUS {
            type TypeKind = ::windows_core::CopyType;
        }
        impl ::core::cmp::PartialEq for DSTORAGE_ERROR_PARAMETERS_STATUS {
            fn eq(&self, other: &Self) -> bool {
                self.StatusArray == other.StatusArray && self.Index == other.Index
            }
        }
        impl ::core::cmp::Eq for DSTORAGE_ERROR_PARAMETERS_STATUS {}
        impl ::core::default::Default for DSTORAGE_ERROR_PARAMETERS_STATUS {
            fn default() -> Self {
                unsafe { ::core::mem::zeroed() }
            }
        }
        #[repr(C)]
        pub struct DSTORAGE_ERROR_RECORD {
            pub FailureCount: u32,
            pub FirstFailure: DSTORAGE_ERROR_FIRST_FAILURE,
        }
        impl ::core::clone::Clone for DSTORAGE_ERROR_RECORD {
            fn clone(&self) -> Self {
                unsafe { ::core::mem::transmute_copy(self) }
            }
        }
        impl ::windows_core::TypeKind for DSTORAGE_ERROR_RECORD {
            type TypeKind = ::windows_core::CopyType;
        }
        impl ::core::default::Default for DSTORAGE_ERROR_RECORD {
            fn default() -> Self {
                unsafe { ::core::mem::zeroed() }
            }
        }
        #[repr(C)]
        pub struct DSTORAGE_QUEUE_DESC {
            pub SourceType: DSTORAGE_REQUEST_SOURCE_TYPE,
            pub Capacity: u16,
            pub Priority: DSTORAGE_PRIORITY,
            pub Name: ::windows_core::PCSTR,
            pub Device: ::std::mem::ManuallyDrop<
                ::core::option::Option<::windows::Win32::Graphics::Direct3D12::ID3D12Device>,
            >,
        }
        impl ::core::clone::Clone for DSTORAGE_QUEUE_DESC {
            fn clone(&self) -> Self {
                unsafe { ::core::mem::transmute_copy(self) }
            }
        }
        impl ::core::fmt::Debug for DSTORAGE_QUEUE_DESC {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                f.debug_struct("DSTORAGE_QUEUE_DESC")
                    .field("SourceType", &self.SourceType)
                    .field("Capacity", &self.Capacity)
                    .field("Priority", &self.Priority)
                    .field("Name", &self.Name)
                    .field("Device", &self.Device)
                    .finish()
            }
        }
        impl ::windows_core::TypeKind for DSTORAGE_QUEUE_DESC {
            type TypeKind = ::windows_core::CopyType;
        }
        impl ::core::cmp::PartialEq for DSTORAGE_QUEUE_DESC {
            fn eq(&self, other: &Self) -> bool {
                self.SourceType == other.SourceType
                    && self.Capacity == other.Capacity
                    && self.Priority == other.Priority
                    && self.Name == other.Name
                    && self.Device == other.Device
            }
        }
        impl ::core::cmp::Eq for DSTORAGE_QUEUE_DESC {}
        impl ::core::default::Default for DSTORAGE_QUEUE_DESC {
            fn default() -> Self {
                unsafe { ::core::mem::zeroed() }
            }
        }
        #[repr(C)]
        pub struct DSTORAGE_QUEUE_INFO {
            pub Desc: DSTORAGE_QUEUE_DESC,
            pub EmptySlotCount: u16,
            pub RequestCountUntilAutoSubmit: u16,
        }
        impl ::core::clone::Clone for DSTORAGE_QUEUE_INFO {
            fn clone(&self) -> Self {
                unsafe { ::core::mem::transmute_copy(self) }
            }
        }
        impl ::core::fmt::Debug for DSTORAGE_QUEUE_INFO {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                f.debug_struct("DSTORAGE_QUEUE_INFO")
                    .field("Desc", &self.Desc)
                    .field("EmptySlotCount", &self.EmptySlotCount)
                    .field(
                        "RequestCountUntilAutoSubmit",
                        &self.RequestCountUntilAutoSubmit,
                    )
                    .finish()
            }
        }
        impl ::windows_core::TypeKind for DSTORAGE_QUEUE_INFO {
            type TypeKind = ::windows_core::CopyType;
        }
        impl ::core::cmp::PartialEq for DSTORAGE_QUEUE_INFO {
            fn eq(&self, other: &Self) -> bool {
                self.Desc == other.Desc
                    && self.EmptySlotCount == other.EmptySlotCount
                    && self.RequestCountUntilAutoSubmit == other.RequestCountUntilAutoSubmit
            }
        }
        impl ::core::cmp::Eq for DSTORAGE_QUEUE_INFO {}
        impl ::core::default::Default for DSTORAGE_QUEUE_INFO {
            fn default() -> Self {
                unsafe { ::core::mem::zeroed() }
            }
        }
        #[repr(C)]
        pub struct DSTORAGE_REQUEST {
            pub Options: DSTORAGE_REQUEST_OPTIONS,
            pub Source: DSTORAGE_SOURCE,
            pub Destination: DSTORAGE_DESTINATION,
            pub UncompressedSize: u32,
            pub CancellationTag: u64,
            pub Name: ::windows_core::PCSTR,
        }
        impl ::core::clone::Clone for DSTORAGE_REQUEST {
            fn clone(&self) -> Self {
                unsafe { ::core::mem::transmute_copy(self) }
            }
        }
        impl ::windows_core::TypeKind for DSTORAGE_REQUEST {
            type TypeKind = ::windows_core::CopyType;
        }
        impl ::core::default::Default for DSTORAGE_REQUEST {
            fn default() -> Self {
                unsafe { ::core::mem::zeroed() }
            }
        }
        #[repr(C)]
        pub struct DSTORAGE_REQUEST_OPTIONS {
            pub _bitfield1: u8,
            pub Reserved1: [u8; 7],
            pub _bitfield2: u64,
        }
        impl ::core::marker::Copy for DSTORAGE_REQUEST_OPTIONS {}
        impl ::core::clone::Clone for DSTORAGE_REQUEST_OPTIONS {
            fn clone(&self) -> Self {
                *self
            }
        }
        impl ::core::fmt::Debug for DSTORAGE_REQUEST_OPTIONS {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                f.debug_struct("DSTORAGE_REQUEST_OPTIONS")
                    .field("_bitfield1", &self._bitfield1)
                    .field("Reserved1", &self.Reserved1)
                    .field("_bitfield2", &self._bitfield2)
                    .finish()
            }
        }
        impl ::windows_core::TypeKind for DSTORAGE_REQUEST_OPTIONS {
            type TypeKind = ::windows_core::CopyType;
        }
        impl ::core::cmp::PartialEq for DSTORAGE_REQUEST_OPTIONS {
            fn eq(&self, other: &Self) -> bool {
                self._bitfield1 == other._bitfield1
                    && self.Reserved1 == other.Reserved1
                    && self._bitfield2 == other._bitfield2
            }
        }
        impl ::core::cmp::Eq for DSTORAGE_REQUEST_OPTIONS {}
        impl ::core::default::Default for DSTORAGE_REQUEST_OPTIONS {
            fn default() -> Self {
                unsafe { ::core::mem::zeroed() }
            }
        }
        #[repr(C)]
        pub union DSTORAGE_SOURCE {
            pub Memory: DSTORAGE_SOURCE_MEMORY,
            pub File: ::std::mem::ManuallyDrop<DSTORAGE_SOURCE_FILE>,
        }
        impl ::core::clone::Clone for DSTORAGE_SOURCE {
            fn clone(&self) -> Self {
                unsafe { ::core::mem::transmute_copy(self) }
            }
        }
        impl ::windows_core::TypeKind for DSTORAGE_SOURCE {
            type TypeKind = ::windows_core::CopyType;
        }
        impl ::core::default::Default for DSTORAGE_SOURCE {
            fn default() -> Self {
                unsafe { ::core::mem::zeroed() }
            }
        }
        #[repr(C)]
        pub struct DSTORAGE_SOURCE_FILE {
            pub Source: ::std::mem::ManuallyDrop<::core::option::Option<IDStorageFile>>,
            pub Offset: u64,
            pub Size: u32,
        }
        impl ::core::clone::Clone for DSTORAGE_SOURCE_FILE {
            fn clone(&self) -> Self {
                unsafe { ::core::mem::transmute_copy(self) }
            }
        }
        impl ::core::fmt::Debug for DSTORAGE_SOURCE_FILE {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                f.debug_struct("DSTORAGE_SOURCE_FILE")
                    .field("Source", &self.Source)
                    .field("Offset", &self.Offset)
                    .field("Size", &self.Size)
                    .finish()
            }
        }
        impl ::windows_core::TypeKind for DSTORAGE_SOURCE_FILE {
            type TypeKind = ::windows_core::CopyType;
        }
        impl ::core::cmp::PartialEq for DSTORAGE_SOURCE_FILE {
            fn eq(&self, other: &Self) -> bool {
                self.Source == other.Source
                    && self.Offset == other.Offset
                    && self.Size == other.Size
            }
        }
        impl ::core::cmp::Eq for DSTORAGE_SOURCE_FILE {}
        impl ::core::default::Default for DSTORAGE_SOURCE_FILE {
            fn default() -> Self {
                unsafe { ::core::mem::zeroed() }
            }
        }
        #[repr(C)]
        pub struct DSTORAGE_SOURCE_MEMORY {
            pub Source: *const ::core::ffi::c_void,
            pub Size: u32,
        }
        impl ::core::marker::Copy for DSTORAGE_SOURCE_MEMORY {}
        impl ::core::clone::Clone for DSTORAGE_SOURCE_MEMORY {
            fn clone(&self) -> Self {
                *self
            }
        }
        impl ::core::fmt::Debug for DSTORAGE_SOURCE_MEMORY {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                f.debug_struct("DSTORAGE_SOURCE_MEMORY")
                    .field("Source", &self.Source)
                    .field("Size", &self.Size)
                    .finish()
            }
        }
        impl ::windows_core::TypeKind for DSTORAGE_SOURCE_MEMORY {
            type TypeKind = ::windows_core::CopyType;
        }
        impl ::core::cmp::PartialEq for DSTORAGE_SOURCE_MEMORY {
            fn eq(&self, other: &Self) -> bool {
                self.Source == other.Source && self.Size == other.Size
            }
        }
        impl ::core::cmp::Eq for DSTORAGE_SOURCE_MEMORY {}
        impl ::core::default::Default for DSTORAGE_SOURCE_MEMORY {
            fn default() -> Self {
                unsafe { ::core::mem::zeroed() }
            }
        }
    }
}
